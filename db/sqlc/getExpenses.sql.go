// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: getExpenses.sql

package db

import (
	"context"
	"database/sql"
)

const fetchAllCapitalExpenses = `-- name: FetchAllCapitalExpenses :many
SELECT 
    capital_exp_id,
    expenses,
    description,
    created_at
FROM capital_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND description LIKE $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllCapitalExpensesParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type FetchAllCapitalExpensesRow struct {
	CapitalExpID int64        `json:"capital_exp_id"`
	Expenses     string       `json:"expenses"`
	Description  string       `json:"description"`
	CreatedAt    sql.NullTime `json:"created_at"`
}

func (q *Queries) FetchAllCapitalExpenses(ctx context.Context, arg FetchAllCapitalExpensesParams) ([]FetchAllCapitalExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllCapitalExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllCapitalExpensesRow{}
	for rows.Next() {
		var i FetchAllCapitalExpensesRow
		if err := rows.Scan(
			&i.CapitalExpID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllEatoutExpenses = `-- name: FetchAllEatoutExpenses :many
SELECT eatout_exp_id,
    expenses,
    description,
    created_at
FROM eatout_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND description LIKE $3
ORDER by created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllEatoutExpensesParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type FetchAllEatoutExpensesRow struct {
	EatoutExpID int64        `json:"eatout_exp_id"`
	Expenses    string       `json:"expenses"`
	Description string       `json:"description"`
	CreatedAt   sql.NullTime `json:"created_at"`
}

func (q *Queries) FetchAllEatoutExpenses(ctx context.Context, arg FetchAllEatoutExpensesParams) ([]FetchAllEatoutExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllEatoutExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllEatoutExpensesRow{}
	for rows.Next() {
		var i FetchAllEatoutExpensesRow
		if err := rows.Scan(
			&i.EatoutExpID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllEntertainmentExpenses = `-- name: FetchAllEntertainmentExpenses :many
SELECT entertainment_exp_id,
    expenses,
    description,
    created_at
FROM entertainment_expenses
WHERE user_id = $1
    AND budget_id = $2
    AND description LIKE $3
ORDER by created_at DESC
LIMIT $4 OFFSET $5
`

type FetchAllEntertainmentExpensesParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type FetchAllEntertainmentExpensesRow struct {
	EntertainmentExpID int64        `json:"entertainment_exp_id"`
	Expenses           string       `json:"expenses"`
	Description        string       `json:"description"`
	CreatedAt          sql.NullTime `json:"created_at"`
}

func (q *Queries) FetchAllEntertainmentExpenses(ctx context.Context, arg FetchAllEntertainmentExpensesParams) ([]FetchAllEntertainmentExpensesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllEntertainmentExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchAllEntertainmentExpensesRow{}
	for rows.Next() {
		var i FetchAllEntertainmentExpensesRow
		if err := rows.Scan(
			&i.EntertainmentExpID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSingleCapitalExpense = `-- name: FetchSingleCapitalExpense :one
SELECT capital_exp_id, budget_id, user_id, expenses, description, created_at
FROM capital_expenses
WHERE capital_exp_id = $1
`

func (q *Queries) FetchSingleCapitalExpense(ctx context.Context, capitalExpID int64) (CapitalExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleCapitalExpense, capitalExpID)
	var i CapitalExpense
	err := row.Scan(
		&i.CapitalExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const fetchSingleEatoutExpense = `-- name: FetchSingleEatoutExpense :one
SELECT eatout_exp_id, budget_id, user_id, expenses, description, created_at
FROM eatout_expenses
WHERE eatout_exp_id = $1
`

func (q *Queries) FetchSingleEatoutExpense(ctx context.Context, eatoutExpID int64) (EatoutExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleEatoutExpense, eatoutExpID)
	var i EatoutExpense
	err := row.Scan(
		&i.EatoutExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const fetchSingleEntertainmentExpense = `-- name: FetchSingleEntertainmentExpense :one
SELECT entertainment_exp_id, budget_id, user_id, expenses, description, created_at
FROM entertainment_expenses
WHERE entertainment_exp_id = $1
`

func (q *Queries) FetchSingleEntertainmentExpense(ctx context.Context, entertainmentExpID int64) (EntertainmentExpense, error) {
	row := q.db.QueryRowContext(ctx, fetchSingleEntertainmentExpense, entertainmentExpID)
	var i EntertainmentExpense
	err := row.Scan(
		&i.EntertainmentExpID,
		&i.BudgetID,
		&i.UserID,
		&i.Expenses,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const fetchTotalRowCountCapital = `-- name: FetchTotalRowCountCapital :one
SELECT
    COUNT(*) AS row_count,
    CAST(COALESCE(CAST(SUM(expenses) AS DECIMAL(10,2)), 0) AS VARCHAR) AS total 
FROM capital_expenses
WHERE user_id = $1
  AND budget_id = $2
  AND description LIKE $3
`

type FetchTotalRowCountCapitalParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

type FetchTotalRowCountCapitalRow struct {
	RowCount int64  `json:"row_count"`
	Total    string `json:"total"`
}

func (q *Queries) FetchTotalRowCountCapital(ctx context.Context, arg FetchTotalRowCountCapitalParams) (FetchTotalRowCountCapitalRow, error) {
	row := q.db.QueryRowContext(ctx, fetchTotalRowCountCapital, arg.UserID, arg.BudgetID, arg.Description)
	var i FetchTotalRowCountCapitalRow
	err := row.Scan(&i.RowCount, &i.Total)
	return i, err
}

const fetchTotalRowCountEatout = `-- name: FetchTotalRowCountEatout :one
SELECT
    COUNT(*) AS row_count,
    CAST(COALESCE(CAST(SUM(expenses) AS DECIMAL(10,2)), 0) AS VARCHAR) AS total 
FROM eatout_expenses
WHERE user_id = $1
  AND budget_id = $2
  AND description LIKE $3
`

type FetchTotalRowCountEatoutParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

type FetchTotalRowCountEatoutRow struct {
	RowCount int64  `json:"row_count"`
	Total    string `json:"total"`
}

func (q *Queries) FetchTotalRowCountEatout(ctx context.Context, arg FetchTotalRowCountEatoutParams) (FetchTotalRowCountEatoutRow, error) {
	row := q.db.QueryRowContext(ctx, fetchTotalRowCountEatout, arg.UserID, arg.BudgetID, arg.Description)
	var i FetchTotalRowCountEatoutRow
	err := row.Scan(&i.RowCount, &i.Total)
	return i, err
}

const fetchTotalRowCountEntertainment = `-- name: FetchTotalRowCountEntertainment :one
SELECT
    COUNT(*) AS row_count,
    CAST(COALESCE(CAST(SUM(expenses) AS DECIMAL(10,2)), 0) AS VARCHAR) AS total 
FROM entertainment_expenses
WHERE user_id = $1
  AND budget_id = $2
  AND description LIKE $3
`

type FetchTotalRowCountEntertainmentParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

type FetchTotalRowCountEntertainmentRow struct {
	RowCount int64  `json:"row_count"`
	Total    string `json:"total"`
}

func (q *Queries) FetchTotalRowCountEntertainment(ctx context.Context, arg FetchTotalRowCountEntertainmentParams) (FetchTotalRowCountEntertainmentRow, error) {
	row := q.db.QueryRowContext(ctx, fetchTotalRowCountEntertainment, arg.UserID, arg.BudgetID, arg.Description)
	var i FetchTotalRowCountEntertainmentRow
	err := row.Scan(&i.RowCount, &i.Total)
	return i, err
}
