// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: searchExpenses.sql

package db

import (
	"context"
)

const countSearchedCapitalRows = `-- name: CountSearchedCapitalRows :one
SELECT COUNT(*) FROM capital_expenses WHERE user_id = $1 AND budget_id = $2 AND description LIKE $3
`

type CountSearchedCapitalRowsParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

func (q *Queries) CountSearchedCapitalRows(ctx context.Context, arg CountSearchedCapitalRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchedCapitalRows, arg.UserID, arg.BudgetID, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchedEatoutRows = `-- name: CountSearchedEatoutRows :one
SELECT COUNT(*) FROM eatout_expenses WHERE user_id = $1 AND budget_id = $2 AND description LIKE $3
`

type CountSearchedEatoutRowsParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

func (q *Queries) CountSearchedEatoutRows(ctx context.Context, arg CountSearchedEatoutRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchedEatoutRows, arg.UserID, arg.BudgetID, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchedEntertainmentRows = `-- name: CountSearchedEntertainmentRows :one
SELECT COUNT(*) FROM entertainment_expenses WHERE user_id = $1 AND budget_id = $2 AND description LIKE $3
`

type CountSearchedEntertainmentRowsParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
}

func (q *Queries) CountSearchedEntertainmentRows(ctx context.Context, arg CountSearchedEntertainmentRowsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchedEntertainmentRows, arg.UserID, arg.BudgetID, arg.Description)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const fetchSearchedCapitalExpenses = `-- name: FetchSearchedCapitalExpenses :many
SELECT capital_exp_id, budget_id, user_id, expenses, description, created_at FROM capital_expenses
WHERE user_id = $1 AND budget_id = $2 AND description LIKE $3
ORDER by created_at DESC
LIMIT $4
OFFSET $5
`

type FetchSearchedCapitalExpensesParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) FetchSearchedCapitalExpenses(ctx context.Context, arg FetchSearchedCapitalExpensesParams) ([]CapitalExpense, error) {
	rows, err := q.db.QueryContext(ctx, fetchSearchedCapitalExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CapitalExpense{}
	for rows.Next() {
		var i CapitalExpense
		if err := rows.Scan(
			&i.CapitalExpID,
			&i.BudgetID,
			&i.UserID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSearchedEatoutExpenses = `-- name: FetchSearchedEatoutExpenses :many
SELECT eatout_exp_id, budget_id, user_id, expenses, description, created_at FROM eatout_expenses
WHERE user_id = $1 AND budget_id = $2 AND description LIKE $3
ORDER by created_at DESC
LIMIT $4
OFFSET $5
`

type FetchSearchedEatoutExpensesParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) FetchSearchedEatoutExpenses(ctx context.Context, arg FetchSearchedEatoutExpensesParams) ([]EatoutExpense, error) {
	rows, err := q.db.QueryContext(ctx, fetchSearchedEatoutExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EatoutExpense{}
	for rows.Next() {
		var i EatoutExpense
		if err := rows.Scan(
			&i.EatoutExpID,
			&i.BudgetID,
			&i.UserID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSearchedEntertainmentExpenses = `-- name: FetchSearchedEntertainmentExpenses :many
SELECT entertainment_exp_id, budget_id, user_id, expenses, description, created_at FROM entertainment_expenses
WHERE user_id = $1 AND budget_id = $2 AND description LIKE $3
ORDER by created_at DESC
LIMIT $4
OFFSET $5
`

type FetchSearchedEntertainmentExpensesParams struct {
	UserID      int64  `json:"user_id"`
	BudgetID    int64  `json:"budget_id"`
	Description string `json:"description"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) FetchSearchedEntertainmentExpenses(ctx context.Context, arg FetchSearchedEntertainmentExpensesParams) ([]EntertainmentExpense, error) {
	rows, err := q.db.QueryContext(ctx, fetchSearchedEntertainmentExpenses,
		arg.UserID,
		arg.BudgetID,
		arg.Description,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntertainmentExpense{}
	for rows.Next() {
		var i EntertainmentExpense
		if err := rows.Scan(
			&i.EntertainmentExpID,
			&i.BudgetID,
			&i.UserID,
			&i.Expenses,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
